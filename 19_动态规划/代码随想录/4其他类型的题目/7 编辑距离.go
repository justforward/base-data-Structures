package main

/*
  392:判断子序列:判断s是否为t的子序列

这个题目算是编辑距离的入门题目，本题只考虑计算删除的情况，不考虑增加和替换的情况
1、dp[i][j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]
2、递推公式：
   if s[i-1]==t[j-1]
    t中找到了一个字符在s中也出现了
   if s[i-1]!=t[j-1]
    相当于t要删除元素，继续匹配

   if(s[i-1]==t[j-1]),那么dp[i-1][j-1]+1;因为找到了一个相同的字符，相同子序列长度
   自然要在dp[i-1][j-1]+1
   if(s[i-1]!=t[j-1]),此时相当于t要删除元素，t如果把当前元素t[j-1]删除，那么dp[i][j]的数值
	就是看s[i-1]与t[j-2]的比较结果了，即：dp[i][j]=dp[i][j-1]
    其实这里 大家可以发现和 1143.最长公共子序列 (opens new window)的递推公式基本那就是一样的，区别就是 本题 如果删元素一定是字符串t，而 1143.最长公共子序列 是两个字符串都可以删元素。
3、初始化
从递推公式可以看出dp[i][j]都是依赖于dp[i - 1][j - 1] 和 dp[i][j - 1]，所以dp[0][0]和dp[i][0]是一定要初始化的。

这里大家已经可以发现，在定义dp[i][j]含义的时候为什么要表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]。
*/

func isSubsequence(s string, t string) bool {
	len1 := len(t)
	len2 := len(s)
	dp := make([][]int, len1+1)
	for i := range dp {
		dp[i] = make([]int, len2+1)
	}

	for i := 1; i <= len1; i++ {
		for j := 1; j <= len2; j++ {
			if t[i-1] == s[j-1] {
				dp[i][j] = dp[i-1][j-1] + 1
			} else {
				dp[i][j] = dp[i-1][j]
			}
		}
	}

	if dp[len1][len2] == len2 {
		return true
	} else {
		return false
	}

}

/*
 115 不同的子序列：给定一个字符串s和一个字符串t，计算在s中t出现的个数
    这个操作也是只有删除操作

1、dp[i][j] 以i-1为结尾的s子序列中出现j-1为结尾的t的个数
2、递推公式：
	s[i-1]==t[j-1]



*/
